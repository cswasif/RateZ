// Frontend integration for zk-wasm
// Note: zk-wasm-pkg is optional and may not be available in all builds
let wasmModule: any = null;
let wasmInitialized = false;

async function loadWasmModule() {
  if (wasmModule) return wasmModule;

  try {
    // Dynamic import with proper error handling
    wasmModule = await import('./zk-wasm-pkg/zk_wasm');
    // Initialize the WASM module
    if (wasmModule && wasmModule.default && !wasmInitialized) {
      await wasmModule.default();
      wasmInitialized = true;
    }
    return wasmModule;
  } catch (error) {
    console.warn('zk-wasm-pkg not available, zk-wasm functionality will be disabled:', error);
    return null;
  }
}

export async function initZK() {
  const module = await loadWasmModule();
  if (!module) {
    throw new Error('zk-wasm-pkg module not available');
  }

  return {
    verifier: new module.ZKWASMVerifier(),
    prover: new module.ZKWASMProver()
  };
}

export async function loadVerifyingKey(verifier: any, vkBytes: Uint8Array): Promise<void> {
  try {
    await verifier.load_verifying_key(vkBytes);
  } catch (error) {
    console.error('Failed to load verifying key:', error);
    throw error;
  }
}

export async function verifyProof(verifier: any, proofBytes: Uint8Array, publicInputs: Uint8Array): Promise<boolean> {
  try {
    return await verifier.verify_proof(proofBytes, publicInputs);
  } catch (error) {
    console.error('Verification failed:', error);
    throw error;
  }
}

export async function generateProof(prover: any, privateInputs: Uint8Array, publicInputs: Uint8Array): Promise<Uint8Array> {
  try {
    return await prover.generate_proof(privateInputs, publicInputs);
  } catch (error) {
    console.error('Proof generation failed:', error);
    throw error;
  }
}

// ============================================================================
// Partial SHA256 Hash Functions for Large Email Headers
// ============================================================================

export interface PartialHashResult {
  /** Intermediate SHA256 state (8 x u32) */
  state: Uint32Array;
  /** Remaining bytes to be processed in circuit */
  remaining: Uint8Array;
  /** Total length of the original message */
  totalLength: number;
  /** Number of bytes that were pre-hashed */
  prehashedLength: number;
}

/**
 * Check if partial hash WASM functions are available
 */
export async function isPartialHashAvailable(): Promise<boolean> {
  const module = await loadWasmModule();
  return module && typeof module.compute_partial_hash_for_email === 'function';
}

/**
 * Compute partial SHA256 hash for an email header.
 * 
 * This function:
 * 1. Finds the "From:" header position
 * 2. Splits at a 64-byte boundary before it
 * 3. Computes SHA256 of the prefix
 * 4. Returns intermediate state + remaining bytes
 * 
 * @param headerBytes - Full email header bytes
 * @param maxRemainingLen - Maximum bytes for circuit (default 2560)
 * @returns Partial hash result with state and remaining bytes
 */
export async function computePartialHash(
  headerBytes: Uint8Array,
  maxRemainingLen: number = 2560
): Promise<PartialHashResult> {
  const module = await loadWasmModule();

  if (!module) {
    throw new Error('zk-wasm module not available for partial hash computation');
  }

  if (typeof module.compute_partial_hash_for_email !== 'function') {
    throw new Error('compute_partial_hash_for_email not found in WASM module. Please rebuild the WASM.');
  }

  try {
    const result = module.compute_partial_hash_for_email(headerBytes, maxRemainingLen);

    return {
      state: new Uint32Array(result.state),
      remaining: new Uint8Array(result.remaining),
      totalLength: Number(result.total_length),
      prehashedLength: Number(result.prehashed_length),
    };
  } catch (error) {
    console.error('Partial hash computation failed:', error);
    throw error;
  }
}

/**
 * Fallback: compute partial hash in pure JavaScript
 * Used when WASM module is not available
 */
export function computePartialHashFallback(
  headerBytes: Uint8Array,
  maxRemainingLen: number = 2560
): PartialHashResult {
  const BLOCK_SIZE = 64;
  const headerLen = headerBytes.length;

  // If small enough, no precomputation needed
  if (headerLen <= maxRemainingLen) {
    return {
      // SHA256 initial state
      state: new Uint32Array([
        0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
        0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,
      ]),
      remaining: headerBytes,
      totalLength: headerLen,
      prehashedLength: 0,
    };
  }

  // Find "From:" header position
  const headerStr = new TextDecoder().decode(headerBytes);
  const fromMatch = headerStr.match(/\r?\nFrom:/i);
  if (!fromMatch || fromMatch.index === undefined) {
    throw new Error('Could not find From: header in email');
  }
  const fromPos = fromMatch.index + (fromMatch[0].startsWith('\r') ? 2 : 1);

  // Calculate split point
  const minSplit = headerLen > maxRemainingLen ? headerLen - maxRemainingLen : 0;
  let splitPoint = Math.floor((fromPos - 1) / BLOCK_SIZE) * BLOCK_SIZE;
  
  // Ensure we don't split too early (leave at least 64 bytes before From header)
  const minSafeSplit = Math.max(0, fromPos - 64);
  
  if (splitPoint < minSplit) {
    splitPoint = Math.floor(minSplit / BLOCK_SIZE) * BLOCK_SIZE;
  }
  
  // Ensure split point is safe (not too close to From header)
  if (splitPoint > minSafeSplit) {
    splitPoint = Math.floor(minSafeSplit / BLOCK_SIZE) * BLOCK_SIZE;
  }
  
  if (splitPoint >= fromPos) {
    throw new Error('Cannot split header: From header is too close to start or email is too small for partial hashing');
  }

  // For fallback, we return initial state and let circuit handle it
  // This won't work for large headers but provides graceful degradation
  console.warn('Using JavaScript fallback - partial hash may not work correctly for very large headers');

  return {
    state: new Uint32Array([
      0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
      0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,
    ]),
    remaining: headerBytes.slice(splitPoint),
    totalLength: headerLen,
    prehashedLength: splitPoint,
  };
}


// ============================================================================
// DKIM Parsing Functions
// ============================================================================

export interface DKIMResult {
  pubkeyModulus: string[];
  pubkeyRedc: string[];
  signature: string[];
  fromHeaderIndex: number;
  fromHeaderLength: number;
  fromAddressIndex: number;
  fromAddressLength: number;
  fromEmail: string;
}

/**
 * Parse DKIM signature and extract circuit inputs using WASM
 * Now fetches REAL public key via DoH
 */
export async function parseDKIMFromEmail(emailBytes: Uint8Array): Promise<DKIMResult> {
  const module = await loadWasmModule();

  if (!module) {
    throw new Error('zk-wasm module not available');
  }

  if (typeof module.parse_dkim_from_email !== 'function') {
    throw new Error('parse_dkim_from_email not found in WASM module. Please rebuild the WASM.');
  }

  try {
    // 1. Parse Email via WASM to get Signature, Selector, Domain
    const result = module.parse_dkim_from_email(emailBytes);
    const selector = result.selector;
    const domain = result.domain;

    console.log(`üîç Found DKIM Selector: ${selector}, Domain: ${domain}`);

    if (!selector || !domain) {
      throw new Error("Could not find selector/domain in DKIM signature");
    }

    // 2. Fetch REAL Public Key from DNS (Google DoH)
    const pubkeyBase64 = await fetchDkimPublicKey(selector, domain);
    console.log("üîë Fetched Real Public Key from DNS");

    // 3. Format Public Key via WASM
    const pubkeyInputs = module.compute_pubkey_inputs(pubkeyBase64);

    console.log("üõ†Ô∏è WASM Generated PubKey Inputs:", pubkeyInputs);
    // Check if REDC is all zeros (indicates old WASM version)
    if (pubkeyInputs.redc.every((limb: string) => limb === "0")) {
      console.error("‚ùå CRTICAL: WASM returned zeroed REDC parameters. You are using an OUTDATED zk-wasm build. Please download the latest artifact from GitHub.");
    } else {
      console.log("‚úÖ REDC parameters look valid (non-zero).");
    }

    return {
      pubkeyModulus: pubkeyInputs.modulus,
      pubkeyRedc: pubkeyInputs.redc,
      signature: result.signature,
      fromHeaderIndex: Number(result.from_header_index),
      fromHeaderLength: Number(result.from_header_length),
      fromAddressIndex: Number(result.from_address_index),
      fromAddressLength: Number(result.from_address_length),
      fromEmail: result.from_email,
    };
  } catch (error) {
    console.error('DKIM parsing failed:', error);
    throw error;
  }
}

/**
 * Fetch DKIM Public Key from DNS using Google DoH
 */
async function fetchDkimPublicKey(selector: string, domain: string): Promise<string> {
  const url = `https://dns.google/resolve?name=${selector}._domainkey.${domain}&type=TXT`;
  try {
    const response = await fetch(url);
    const data = await response.json();

    if (!data.Answer || data.Answer.length === 0) {
      throw new Error("No DNS TXT record found for DKIM key");
    }

    // Combine multiple strings if split
    // Record format: "v=DKIM1; k=rsa; p=MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCpK..."
    const txtRecord = data.Answer[0].data.replace(/"/g, '');

    // Extract p= (public key)
    const match = txtRecord.match(/p=([^;]+)/);
    if (!match) {
      throw new Error("No public key (p=) found in DNS record");
    }

    return match[1].replace(/\s/g, '');
  } catch (e) {
    console.error("DNS Lookup failed:", e);
    // Fallback for testing ONLY if DNS fails (e.g. offline)
    // This is Google's 2023 key as an example, but we really want the live one
    throw new Error(`Failed to fetch DKIM key: ${e instanceof Error ? e.message : String(e)}`);
  }
}